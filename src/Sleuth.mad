import Char from "Char"
import IO from "IO"
import List from "List"
import { Just, Nothing, fromMaybe } from "Maybe"
import String from "String"



// export type MatchKind = MatchNormal | MatchEmpty | MatchWildcard
// export type Match = Match(MatchKind, Char)
//
// export wildcard = Match(MatchWildcard, '.')
// export empty = Match(MatchEmpty, '?')
//
// export isWildcard = where {
//   Match(MatchWildcard, _) => true
//   _ => false
// }
//
// export isEmpty = where {
//   Match(MatchEmpty, _) => true
//   _ => false
// }
//
// matchChar :: Match -> Char -> Boolean
// export matchChar = (m, c) => where (m) {
//   Match(MatchEmpty, _) => true
//   Match(MatchWildcard, _) => true
//   Match(_, d) => d == c
// }

matchChar :: Char -> Char -> Boolean
export matchChar = (d, c) => d == '.' || d == c

matchCharList :: List Char -> List Char -> Boolean
export matchCharList = (pattern, input) => {
  pLen = List.length(pattern)
  iLen = List.length(input)

  return if (pLen == 1 && pattern == ['$'] && iLen == 0) {
    true
  } else if (pLen == 0 && iLen != 0) {
    true
  } else if (iLen == 0 && pLen != 0) {
    false
  } else {
    where(#[pattern, input]) {
      #[_, []] =>
        true

      #[[a, ...z], [a2, ...z2]] =>
        matchChar(a, a2) && matchCharList(z, z2)
    }
  }
}

match :: String -> String -> Boolean
export match = (pattern, input) => pipe(
  matchCharList(String.toList(pattern)),
)(String.toList(input))

_sliceToEnd :: Integer -> String -> String
_sliceToEnd = (i, x) => String.slice(i, String.length(x), x)

search :: String -> String -> Boolean
export search = (pattern, input) => if (String.startsWith("^", pattern)) {
  match(_sliceToEnd(1, pattern), input)
} else {
  pipe(
    String.length,
    List.range(0),
    List.any(
      (i) => {
        segment = _sliceToEnd(i, input)
        matched = match(pattern, segment)
        IO.pTrace("checking", #[i, pattern, segment, matched])
        return matched
      },
    ),
  )(input)
}
